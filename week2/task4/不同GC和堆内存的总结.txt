
不同GC和堆内存的关系

堆内存越大，执行youngGC和fullGC的次数越少；
堆内存越大，单次youngGC和fullGC的执行时间越长；
堆内存同等大小情况下，串行GC的时间要高于并行GC；
堆内存越大，G1 GC的效率越高，吞吐量和GC时间上都优于串行GC，并行GC以及CMS GC；
	
如何选择GC

大多数JVM都需要使用两种不同的GC算法，一种用来清理年轻代，另一种用来清理老年代。

串行GC对年轻代使用 mark-copy（标记-复制）算法，对老年代使用 mark-sweep-compact（标记-清除-整理）算法。
串行GC只适合几百MB堆内存的JVM，而且是单核CPU时比较有用。
对于服务器端来说，因为一般是多个CPU内核，并不推荐使用，除非确实需要限制JVM所使用的资源。
大多数服务器端应用部署在多核平台上，选择串行GC就意味着人为地限制了系统资源的使用，会导致资源闲置，多余的CPU资源也不能用增加业务处理的吞吐量。

并行GC在年轻代使用 mark-copy（标记-复制）算法 ，在老年代使用 mark-sweep-compact（标记-清除-整理）算法。
并行GC适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量:
在GC期间，所有CPU内核都在并行清理垃圾，所以总暂停时间更短；
在两次GC周期的间隔期，没有GC线程在运行，不会消耗任何系统资源。
因为并行GC的所有阶段都不能中断，所以并行GC很容易出现较长时间的卡顿。
如果系统的主要目标是最低的停顿时间/延迟，而不是整体的吞吐量最大，那么就应该选择其他垃圾收集器组合。

CMS GC对年轻代采用并行STW方式的 mark-copy（标记-复制）算法，对老年代主要使用并发 mark-sweep（标记-清除）算法。
CMS GC的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：
第一，不对老年代进行整理，而是使用空闲列表(free-lists)来管理内存空间的回收。
第二，在 mark-and-sweep (标记-清除) 阶段的大部分工作和应用线程一起并发执行。
也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢CPU时间。
默认情况下，CMS使用的并发线程数等于CPU核心数的1/4。
如果服务器是多核CPU，并且主要调优目标是降低GC停顿导致的系统延迟，那么使用CMS是个很明智的选择。
通过减少每一次GC停顿的时间，很多时候会直接改善系统的用户体验。
因为多数时候都有部分CPU资源被GC消耗，所以在CPU资源受限的情况下，CMS GC会比并行GC的吞吐量差一些。

G1 GC最主要的设计目标是：将STW停顿的时间和分布，变成可预期且可配置的。
事实上，G1 GC是一款软实时垃圾收集器，可以为其设置某项特定的性能指标。
对单业务延迟非常敏感的系统来说，如果CPU资源不受限制，那么G1可以说是HotSpot中最好的选择，特别是在最新版本的JVM中。
当然这种降低延迟的优化也不是没有代价的：由于额外的写屏障和守护线程，G1的开销会更大。
如果系统属于吞吐量优先型的，又或者CPU持续占用100%，而又不在乎单次GC的暂停时间，那么CMS是更好的选择。

选择正确的GC算法，唯一可行的方式就是去尝试，并找出不合理的地方，一般性的指导原则：
如果系统考虑吞吐优先，CPU资源都用来最大程度处理业务，用并行GC；
如果系统考虑低延迟有限，每次GC时间尽量短，用CMS GC；
如果系统内存堆较大，同时希望整体来看平均GC时间可控，使用G1 GC。
对于内存大小的考量：
一般4G以上，算是比较大，用G1的性价比较高。
一般超过8G，比如16G-64G内存，非常推荐使用G1 GC。